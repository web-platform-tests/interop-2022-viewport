<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Visual Viewport Debugger</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../base.css" />

    <style>
        html {
            outline: 10px dashed red;
            outline-offset: -10px;
        }

        body {
            height: 300%;
            position: relative;
        }

        .bar {
            position: absolute;
            top: 0;
            left: calc(50% - 1em);
            bottom: 0;
            width: 2em;
            background: cyan;
            background-image:
                linear-gradient(to bottom, darkmagenta 10px, transparent 1px),
                linear-gradient(to top, slateblue 10px, transparent 1px);
            background-size: 100% calc(100% / 3);
        }

        #debug,
        #visualviewport,
        #layoutviewport {    
            pointer-events: none;
            padding: 1em;
            overflow-y: hidden;
        }

        #layoutviewport {
            position: fixed;
            inset: 0;
            border: 5px dotted blue;
            z-index: 999;
        }

        #debug,
        [data-vv-positioning="absolute"] #visualviewport {
            position: absolute;
            top: var(--vvpt, 0px);
            left: var(--vvpl, 0px);
            width: var(--vvw, 100%);
            height: var(--vvh, 100%);
            font-size: calc(1em / var(--vvz, 1));
        }

        [data-vv-positioning="fixed"] #visualviewport {
            position: fixed;
            top: var(--vvot, 0px);
            left: var(--vvol, 0px);
            width: var(--vvw, 100%);
            height: var(--vvh, 100%);
            right: var(--vvol, 0px) + var(--vvw, 0px);
            bottom: var(--vvol, 0px) + var(--vvh, 0px);
        }

        #visualviewport {
            border: 8px solid;
            border-image: repeating-linear-gradient(
                45deg,
                orange,
                orange 10px,
                transparent 10px,
                transparent 20px
                )
                10;
        }

        #debug div {
            white-space: pre-wrap;
            font-family: monospace;
        }

        main {
            position: absolute;
            right: 10vw;
            top: 10vh;
        }

        input {
            font-size: 16px; /* To prevent auto-zoom on iOS */
        }
    </style>

    <script type="module">
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        const getVisualViewPortValues = ({ clampOffsets = false, resizeDimensions = false }) => {
            let {
                width,
                height,
                widthOrig = null,
                heightOrig = null,
                scale,
                offsetTop,
                offsetLeft,
                offsetTopOrig = null,
                offsetLeftOrig = null,
                pageLeft,
                pageTop,
                pageLeftOrig = null,
                pageTopOrig = null,
            } = window.visualViewport;

            // Adjust values by clamping
            if (clampOffsets) {
                // Cache original values
                pageTopOrig = pageTop;
                pageLeftOrig = pageLeft;
                offsetTopOrig = offsetTop;
                offsetLeftOrig = offsetLeft;
                
                // Page offsets cannot go negative, nor exceed the max scroll offset
                // @note: Used for absolute positioning
                pageTop = clamp(pageTop, 0, document.body.offsetHeight - height);
                pageLeft = clamp(pageLeft, 0, document.body.offsetWidth - width);

                // (fixedpos) Layout Viewport offsets cannot go negative, nor exceed the max offset within the Layout Viewport
                // @note: Used for fixed positioning
                const layoutViewportHeight = (window.innerHeight * scale); // @TODO: This only is true when window.innerHeight resizes. Which is not always the case when pinch-zooming (or which happens too late as UA UI shows/hides)
                const layoutViewportWidth = (window.innerWidth * scale); // @TODO: This only is true when window.innerHeight resizes. Which is not always the case when pinch-zooming (or which happens too late as UA UI shows/hides)
                offsetTop = clamp(offsetTop, 0, layoutViewportHeight - height);
                offsetLeft = clamp(offsetLeft, 0, layoutViewportWidth - width);
            }

            // Adjust values by resizing height/width
            // Only needed for browsers that expose overscrolling through scrollX/scrollY
            if (resizeDimensions) {
                widthOrig = width;
                heightOrig = height;
                pageTopOrig = pageTop;
                pageLeftOrig = pageLeft;
                offsetTopOrig = offsetTop;
                offsetLeftOrig = offsetLeft;

                // @TODO: Find a way to not rely on UA sniffing …
                const isMobileSafari = CSS.supports("-webkit-overflow-scrolling: touch") && (!!window.navigator.userAgent.match(/iPad/i) || !!window.navigator.userAgent.match(/iPhone/i));

                if (width + pageLeft > document.body.offsetWidth) {
                    width = document.body.offsetWidth - pageLeft;

                    // Mobile Safari: Fixed Viewport does overscroll. Max value can overshoot 0 (inverse of overScrollY) and min value can exceed inverted max scroll distance
                    if (isMobileSafari) {
                        if (scale == 1) offsetLeft -= (widthOrig - width);
                        if (offsetLeft < 0) offsetLeft = -offsetLeft;
                    }
                    // Desktop Safari: Fixed Viewport does not overscroll. Max value is 0, Min value is inverted max scroll distance.
                    else {
                        offsetLeft += (widthOrig - width); // Add overscroll value to the offset
                    }
                }
                if (height + pageTop > document.body.offsetHeight) {
                    height = document.body.offsetHeight - pageTop;

                    // Mobile Safari: Fixed Viewport does overscroll. Max value can overshoot 0 (inverse of overScrollY) and min value can exceed inverted max scroll distance
                    if (isMobileSafari) {
                        if (scale == 1) offsetTop -= (heightOrig - height);
                        if (offsetTop < 0) offsetTop = -offsetTop;
                    }
                    // Desktop Safari: Fixed Viewport does not overscroll. Max value is 0, Min value is inverted max scroll distance.
                    else {
                        offsetTop += (heightOrig - height); // Add overscroll value to the offset
                    }
                }
                if (pageLeft < 0) {
                    width += pageLeft;
                    pageLeft = 0;

                    // @note: Used for fixed positioning
                    offsetLeft = Math.abs(offsetLeft);
                }
                if (pageTop < 0) {
                    height += pageTop;
                    pageTop = 0;

                    // @note: Used for fixed positioning
                    offsetTop = Math.abs(offsetTop);
                }

            }

            return Object.fromEntries(
                Object.entries({
                    width,
                    widthOrig,
                    height,
                    heightOrig,
                    scale,
                    offsetTop,
                    offsetTopOrig,
                    offsetLeft,
                    offsetLeftOrig,
                    pageLeft,
                    pageLeftOrig,
                    pageTop,
                    pageTopOrig,
                })
                .filter(([k, v]) => v !== null)
            );
        };

        const syncVisualViewportValuesToCustomProperties = (vvv, $el = document.documentElement) => {
            $el.style.setProperty('--vvw', `${vvv.width}px`);
            $el.style.setProperty('--vvh', `${vvv.height}px`);
            $el.style.setProperty('--vvpt', `${vvv.pageTop}px`);
            $el.style.setProperty('--vvpl', `${vvv.pageLeft}px`);
            $el.style.setProperty('--vvot', `${vvv.offsetTop}px`);
            $el.style.setProperty('--vvol', `${vvv.offsetLeft}px`);
            $el.style.setProperty('--vvz', vvv.scale);
        }

        const getScrollValues = () => {
            let {
                scrollX,
                scrollY,
            } = window;

            const overScrollX = scrollX < 0 ? scrollX : Math.max(0, scrollX + window.innerWidth - document.body.offsetWidth);
            const overScrollY = scrollY < 0 ? scrollY : Math.max(0, scrollY + window.innerHeight - document.body.offsetHeight);

            return {
                scrollX,
                scrollY,
                overScrollX,
                overScrollY,
            };
        }

        const getBodyValues = () => {
            let {
                offsetHeight,
                offsetWidth,
            } = document.body;

            return {
                offsetHeight,
                offsetWidth,
            };
        }

        const write = (vals, $el) => {
            $el.innerText = JSON.stringify(vals, null, 4);
        }

        const getLayoutViewportValues = () => {
            // @NOTE: You might think we could use window.innerHeight/innerWidth for this
            // but this is not true: when overscrolling Safari into a pull-to-refresh,
            // the window.innerHeight shrinks, but the layout viewport remains the same.
            const layoutViewport = document.querySelector("#layoutviewport");
            return layoutViewport.getBoundingClientRect();
        };

        const update = (e) => {
            document.body.setAttribute('data-vv-positioning', document.querySelector('[name="vvPosition"]:checked').value);

            const vvv = getVisualViewPortValues({
                clampOffsets: document.querySelectorAll('#vvAdjustValuesByClamping:checked').length > 0,
                resizeDimensions: document.querySelectorAll('#vvAdjustValuesByResizing:checked').length > 0,
            });
            syncVisualViewportValuesToCustomProperties(vvv);
            write(vvv, document.querySelector("#vv-values"));

            const sv = getScrollValues();
            write(sv, document.querySelector("#s-values"));

            // const bv = getBodyValues();
            // write(bv, document.querySelector("#b-values"));

            // const lv = getLayoutViewportValues();
            // write(lv, document.querySelector("#lv-values"));
        };

        // Show/Hide Options Dialog
        document.querySelector('#btnOptions').addEventListener('click', (e) => {
            e.preventDefault();
            document.querySelector('#options').showModal();
        });
        document.querySelector('#btnOptionsClose').addEventListener('click', (e) => {
            e.preventDefault();
            document.querySelector('#options').close();
        });

        // Update on scroll/resize
        window.addEventListener('scroll', update, { passive: true });
        window.visualViewport.addEventListener('scroll', update, { passive: true });
        window.visualViewport.addEventListener('resize', update, { passive: true });

        // Update after closing the options
        document.querySelector('#options').addEventListener('close', update);

        // Make sure we have values on load
        setTimeout(update, 100);
    </script>
</head>

<body translate="no" data-vv-positioning="absolute">
    <div class="bar"></div>
    <main>
        <input type="text" />
    </main>

    <div id="debug">
        <h1>Visual Viewport Debugger</h1>
        <div id="lv-values"></div>
        <div id="vv-values"></div>
        <div id="s-values"></div>
        <div id="b-values"></div>
        <div id="eventlog"></div>
    </div>

    <div id="visualviewport"></div>
    <div id="layoutviewport"></div>

    <details>
        <summary>Legend</summary>
        <ul>
            <li>Red dashed line = ICB</li>
            <li>Blue dotted line = Layout Viewport</li>
            <li>Orange slanted line = Visual Viewport</li>
        </ul>
        <p><i>Expected Behavior: Orange lines should always be visible and touch the edges of the visible space. Can lag.</i></p>
    </details>

    <button id="btnOptions">options</button>
    <dialog id="options">
        <header>
            <button id="btnOptionsClose">close</button>
            <h1>Options</h1>
        </header>
        <section>
            <h3>Visual Viewport</h3>
            <p>Some browsers allow negative <code>scrollX</code>/<code>scrollY</code>, and allow the same for the Visual Viewport’s <code>pageTop</code>/<code>pageLeft</code>. This may conflict with positioning the Visual Viewport box, so there’s a few fixes one can apply</p>
            <div class="option"><input type="radio" id="vvAdjustValuesNo" name="vvAdjustValues" checked /><label for="vvAdjustValuesNo">Do not adjust values when overscrolling</label></div>
            <div class="option"><input type="radio" id="vvAdjustValuesByClamping" name="vvAdjustValues" /><label for="vvAdjustValuesByClamping">Clamp values between 0 and max scroll when overscrolling</label></div>
            <div class="option"><input type="radio" id="vvAdjustValuesByResizing" name="vvAdjustValues" /><label for="vvAdjustValuesByResizing">Shrink height/width when overscrolling</label></div>
            <p>Positioning method to use</p>
            <div class="option"><input type="radio" id="vvPositionAbsolute" name="vvPosition" value="absolute" checked /><label for="vvPositionAbsolute"><code>position: absolute;</code></label></div>
            <div class="option"><input type="radio" id="vvPositionFixed" name="vvPosition" value="fixed" /><label for="vvPositionFixed"><code>position: fixed;</code></label></div>
        </section>
        <section>
            <h3>Virtual Keyboard</h3>
            <div class="option"><input type="checkbox" id="optVirtualKeyboardOverlaysContent" name="optVirtualKeyboardOverlaysContent" /><label for="optVirtualKeyboardOverlaysContent">Virtual Keyboard Overlays Content</label></div>
        </section>
    </dialog>
</body>
</html>
